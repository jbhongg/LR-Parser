# LR-Parser

### 코드 설명

 이 코드는 어휘분석기(Lexical analysis)와 LR파서를 결합하였습니다. 그러므로 예를 들어 min*60+sec을 입력으로 넣으면 이 문자열들을 토큰으로 변경해주고 이것을 문법에 맞는지 파싱하는 과정인 LR파서를 통해 문법에 맞는지 아닌지를 판단해 줍니다.
먼저 어휘분석기에 대한 코드 설명은 문자열을 입력 받을 땐 동적할당을 통해서 입력을 받고 입력받은 문자열을 make_token함수에 입력으로 넣어서 어휘 분석을 하였습니다. 일단 입력한 문자열을 다시 한 번 출력해서 확인해 주고, +, *, (, ), 문자, 숫자를 각각의 else if문으로 구현하였습니다. 
 문자나 숫자는 연속된 문자들과 숫자들로 이루어 진 부분을 하나의 문자열, 숫자열로 취급하게 하기 위해서 while문안에 다음 문자가 같은 종류이면 계속 다음 문자를 읽고, 
만약 다른 종류의 문자열이 읽힌다면 while문을 빠져나가서 각각에 해당하는 토큰번호를 
배열에 저장하고, 다른 종류의 문자열을 읽기위해 백트랙킹 하는 방법을 선택했습니다. 
 다음으로 어휘분석기에서 만든 토큰배열을 다시 변환하여 arr배열에 저장하고, LR파서 함수 부분에 stack배열을 선언한 후 첫 번째 배열은 0 으로 초기화 합니다.
그 후 토큰 배열에 들어있는 토큰 번호들은 전부 읽을 때 까지(코드에는 무한루프로 표시했지만, Accept를 만나거나 파싱테이블에 적용시킬 수 없는 상황이 오면 return 으로 판단을 함과 동시에 프로그램을 종료하도록 프로그래밍 하였습니다.) 반복 시킵니다.
그 후 파싱 테이블에 표기되어있는 대로 조건문을 적어서 stack배열에 값을 쌓고, 쌓일때마다 stack_num을 증가시켜서 stack배열의 top인덱스를 표시해 줬습니다. 파싱 테이블은 크게 Shift, Reduce, goto 이 3가지의 방식으로 구성되어있는데, 
 그 중 Shift 가 나왔을 시, stack배열의 탑을 증가시키고 arr배열에서 보내주는 기호를 보내줍니다. 그 후 상태를 바꿔야 하므로 stack배열의 탑을 한번 더 증가 시키고, 상태에 맞는 숫자를 stack배열에 쌓습니다. 그 후 Shift연산을 했다는 문장을 출력해 줍니다.
 Reduce가 나왔을 경우에는 과제ppt위에 적어주신 문법에 맞게 stack배열을 바꿔주고 그 이후 스택들은 비워줘야 합니다. 그러므로 stack배열의 처음부터 문법에 맞는 문자를 찾고 그 문자를 바꾼 후, 그 이후 문자들은 초기화 시킵니다. (만약 E + F같은 3가지의 문자를 판단해야 할 경우에는 첫 번째 문자(E)를 찾고 그 이후부터 또 반복문을 실행시켜서 +를 찾고 또 그 이후부터 반복문을 실행시킨 후 F를 찾으면 첫 번째 문자(E)를 찾은 위치로 돌아가서 그 문자를 바꾸고 그 이후 문자들은 초기화 시킵니다.) 그리고 가장 중요한 작업인
스택 탑을 바꾼 문자의 위치에 이동 시킨 후 그 바로 밑 숫자를 상태로 인식하게 합니다.
 마지막으로 goto같은 경우에는 stack배열에 ‘상태숫자 문자’의 형태로 저장되어 있을 것이므로 상태 다음의 문자가 E나 F나 T일 경우 goto를 실행시켜서 스택탑을 1 증가시키고 그 위치에 goto에 맞는 숫자를 stack배열에 쌓는 방식으로 프로그래밍 하였습니다.
 
 <br>
 
 ### 실행 결과
 
 #### 1. min*60+sec
 
 ![image01](https://user-images.githubusercontent.com/43925006/155854458-def131d1-5840-4f39-bff0-4f118c63f51a.png)
 
 #### 2. sum3+40/id
 
 ![image02](https://user-images.githubusercontent.com/43925006/155854460-264a1f0b-f252-4829-b1eb-f9aef9d1ecf8.png)

 
